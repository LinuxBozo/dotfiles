#!/usr/bin/env bash

# Shell prompt based on the Solarized Dark theme.
# Screenshot: http://i.imgur.com/EkEtphC.png
# Heavily inspired by @necolas’s prompt: https://github.com/necolas/dotfiles
# iTerm → Profiles → Text → use 13pt Monaco with 1.1 vertical spacing.

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM='gnome-256color';
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM='xterm-256color';
fi;

if tput setaf 1 &> /dev/null; then
    tput sgr0; # reset colors
    bold=$(tput bold);
    reset=$(tput sgr0);
    black=$(tput setaf 0);
    blue=$(tput setaf 33);
    cyan=$(tput setaf 37);
    green=$(tput setaf 40);
    orange=$(tput setaf 214);
    purple=$(tput setaf 125);
    red=$(tput setaf 160);
    violet=$(tput setaf 61);
    white=$(tput setaf 15);
    yellow=$(tput setaf 220);
else
    bold='';
    reset="\e[0m";
    black="\e[1;30m";
    blue="\e[1;34m";
    cyan="\e[1;36m";
    green="\e[1;32m";
    orange="\e[1;33m";
    purple="\e[1;35m";
    red="\e[1;31m";
    violet="\e[1;35m";
    white="\e[1;37m";
    yellow="\e[1;33m";
fi;

#### vcs colors
         init_vcs_color=${white}        # initial
        clean_vcs_color=${blue}        # nothing to commit (working directory clean)
     modified_vcs_color=${green}      # Changed but not updated:
        added_vcs_color=${yellow}       # Changes to be committed:
     addmoded_vcs_color=${yellow}
    untracked_vcs_color=${cyan}    # Untracked files:
           op_vcs_color=${purple}
     detached_vcs_color=${red}
          hex_vcs_color=${black}         # gray

prompt_git() {
    local rawhex_len=${rawhex_len:-5}

    local s='';
    local branchName='';

    # Check if the current directory is in a Git repository.
    if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

        unset branchName status modified added clean init added mixed untracked op detached freshness
        git_dir=`git rev-parse --git-dir 2> /dev/null`

        # check if the current directory is in .git before running git checks
        if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

            # Ensure the index is up to date.
            git update-index --really-refresh -q &>/dev/null;

            # Check for uncommitted changes in the index.
            if ! $(git diff --quiet --ignore-submodules --cached); then
                s+="${added_vcs_color}✚ ";
                added=added;
            fi;

            # Check for unstaged changes.
            if ! $(git diff-files --quiet --ignore-submodules --); then
                s+="${modified_vcs_color}✼ ";
                modified=modified;
            fi;

            # Check for untracked files.
            if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                s+="${untracked_vcs_color}⁇ ";
                untracked=untracked;
            fi;

            # Check for stashed files.
            if $(git rev-parse --verify refs/stash &>/dev/null); then
                s+="${detached_vcs_color}$ ";
            fi;

        fi;

        if  ! grep -q "^ref:" "$git_dir/HEAD"  2>/dev/null;   then
            detached=detached
        fi

        #################  GET GIT OP

        unset op
        if [[ -d "$git_dir/.dotest" ]] ;  then
            if [[ -f "$git_dir/.dotest/rebasing" ]] ;  then
                op="rebase"
            elif [[ -f "$git_dir/.dotest/applying" ]] ; then
                op="am"
            else
                op="am/rebase"
            fi
        elif  [[ -f "$git_dir/.dotest-merge/interactive" ]] ;  then
            op="rebase -i"
        elif  [[ -d "$git_dir/.dotest-merge" ]] ;  then
            op="rebase -m"
        elif  [[ -f "$git_dir/MERGE_HEAD" ]] ;  then
            op="merge"
        elif  [[ -f "$git_dir/index.lock" ]] ;  then
            op="locked"
        else
            [[  -f "$git_dir/BISECT_LOG"  ]]   &&  op="bisect"
        fi

        # Get the short symbolic ref.
        # If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
        # Otherwise, just give up.
        branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            git rev-parse --short HEAD 2> /dev/null || \
            echo '(unknown)')";

        [ -n "${s}" ] && s=" ${white}[ ${s}${white}]";

        if  [[ $rawhex_len -gt 0 ]] ;  then
            rawhex=`git rev-parse HEAD 2>/dev/null`
            rawhex=${rawhex/HEAD/}
            rawhex="$hex_vcs_color${rawhex:0:$rawhex_len}"
        else
            rawhex=""
        fi

        freshness="${white}="
        eval " $(
            LANG=C git status 2>/dev/null |
                sed -n '
                    s/^\(# \)*On branch /branch=/p
                    s/^nothing to commi.*/clean=clean/p
                    s/^\(# \)*Initial commi.*/init=init/p
                    s/^\(# \)*Your branch is ahead of.*/freshness=${yellow}↑/p
                    s/^\(# \)*Your branch is behind.*/freshness=${violet}↓/p
                    s/^\(# \)*Your branch and \(.\).\+\1 have diverged.*/freshness=${orange}↕/p
                '
        )"

        if [[ $init ]];  then
            vcs_info="${white}init"
        else
            if [[ "$detached" ]] ;  then
                branchName="<detached:`git name-rev --name-only HEAD 2>/dev/null`"
            elif   [[ "$op" ]];  then
                branchName="$op:$branch"
                if [[ "$op" == "merge" ]] ;  then
                    branchName+="<--$(git name-rev --name-only $(<$git_dir/MERGE_HEAD))"
                fi
            fi
            vcs_info="$branchName$freshness$rawhex"
        fi

        ### status:  choose primary (for branch color)
        status=${op:+op}
        status=${status:-$detached}
        status=${status:-$clean}
        status=${status:-$modified}
        status=${status:-$added}
        status=${status:-$untracked}
        status=${status:-$init}
                                # at least one should be set
                                : ${status?prompt internal error: git status}

        eval vcs_color="\${${status}_vcs_color}"
        echo -e "${1}${vcs_color}${vcs_info}${2}${s}";
    else
        return;
    fi;
}

prompt_command_func() {
    unset git_info
    # Highlight the user name when logged in as root.
    if [[ "${USER}" == "root" ]]; then
        userStyle="${red}";
    else
        userStyle="${orange}";
    fi;

    # Highlight the hostname when connected via SSH.
    if [[ "${SSH_TTY}" ]]; then
        hostStyle="${bold}${red}";
    else
        hostStyle="${yellow}";
    fi;

    #git_info="\$(prompt_git \"\[${white}\] on \[\]\" \"\[\]\")"; # Git repository details

    # Set the terminal title and prompt.
    PS1="\[\033]0;\W\007\]"; # working directory base name
    #PS1+="\[${bold}\]\n"; # newline
    #PS1+="\[${userStyle}\]\u"; # username
    #PS1+="\[${white}\]@";
    #PS1+="\[${hostStyle}\]\h"; # host
    #PS1+="\[${white}\] in ";
    #PS1+="\[${green}\]\w"; # working directory full path
    #PS1+=$git_info;
    #PS1+="\n";
    PS1+="\[${green}\]\$ \[${reset}\]"; # `$` (and reset color)
    export PS1;

    PS2="\[${yellow}\]→ \[${reset}\]";
    export PS2;
}
#PROMPT_COMMAND=prompt_command_func
# Git prompt
# [[ $- == *i* ]]  &&  source $HOME/.git-prompt.sh

# https://github.com/starship/starship
eval "$(starship init bash)"

